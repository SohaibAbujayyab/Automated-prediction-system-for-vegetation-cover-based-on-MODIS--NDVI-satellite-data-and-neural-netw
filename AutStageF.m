% -------------------------------------------------------------------------------
% Name:           AutStageF.m
% Description:    Matlab-vegetation cover prediction
% Purpose:        Automated prediction system for vegetation cover based on MODIS- NDVI satellite data and neural networks
% Author:         Sohaib K. M. Abujayyab
% Created:        11/02/2019
% Requirements: None
% -------------------------------------------------------------------------------
%% make list of input tiles of shp files 
clear
clc
[file,path] = uigetfile('*.shp*','MultiSelect','on');

%% 
Nmuberofsteps=20;
clc
b=1;
[m,n] = size(file);
disp(b + " Out of " + n)
steps_len=n;
stepi=0;
str2=sprintf('b=%d.........%.2f%%',b,(stepi/steps_len)*100);
disp(str2);
 
%% 
for b=1:n   %n     %for loop of each PointsTile file
    tic    
    NameOfPointsTile=file(1,b);
    NameOfPointsTile2 = char(NameOfPointsTile);
    NameOfPointsTile3 = NameOfPointsTile2(1:end-4);
    PathOfPointsTile = fullfile(path,NameOfPointsTile3);
    % disp(PathOfPointsTile)
    S = shaperead(PathOfPointsTile);   %read Shapefile (Shapefile must not have any other fields) 
    A_cell = struct2cell(S);
    YY2 = A_cell(6:end,:)';     %clean the data and take only numbers
    [m,n] = size(YY2);

    
%     for mm=1:m               %m
%         YY23=YY2(m,:);
%         YY24 = cell2mat(YY23)';
%         
%         for i=1:n
%             maxx=max(YY24);
%             minn=min(YY24);
%             NormalizedYY24(i,mm)=(YY24(i,1)-minn)/(maxx-minn);
%         end
%     end
%         
%     NormalizedYY24=NormalizedYY24';
%     for f=1:n
%         for k=1:m
%             NormalizedYY25{k,f}=NormalizedYY24(k,f);
%         end
%     end
  
    performance2=[];
    NDVI=[];
    for k=1:m     %   m  for loop of each pixcel(Time-Series)
        %disp(k) 
        T = YY2(k,1:n);
        % Solve an Autoregression Time-Series Problem with a NAR Neural Network
        % Script generated by Neural Time Series app
        % Created 06-Jan-2019 03:09:06
        %
        % This script assumes this variable is defined:
        %
        %   T - feedback time series.
 
        % Choose a Training Function
        % For a list of all training functions type: help nntrain
        % 'trainlm' is usually fastest.
        % 'trainbr' takes longer but may be better for challenging problems.
        % 'trainscg' uses less memory. Suitable in low memory situations.
         trainFcn = 'trainlm';  % Levenberg-Marquardt backpropagation.
%        trainFcn = 'trainbr'; 
%        trainFcn = 'trainscg'; %
 
        % Create a Nonlinear Autoregressive Network
        feedbackDelays = 1:2;
        hiddenLayerSize = 33;
        net = narnet(feedbackDelays,hiddenLayerSize,'open',trainFcn);
        % Prepare the Data for Training and Simulation
        % The function PREPARETS prepares timeseries data for a particular network,
        % shifting time by the minimum amount to fill input states and layer
        % states. Using PREPARETS allows you to keep your original time series data
        % unchanged, while easily customizing it for networks with differing
        % numbers of delays, with open loop or closed loop feedback modes.
        [x,xi,ai,t] = preparets(net,{},{},T);
        % Setup Division of Data for Training, Validation, Testing
%         net.divideParam.trainRatio = 70/100;
%         net.divideParam.valRatio = 15/100;
%         net.divideParam.testRatio = 15/100;

        net.trainParam.showWindow = 0;
        net.trainParam.showCommandLine = 0;
 
        % Train the Network
        [net,tr] = train(net,x,t,xi,ai);
        
        % Test the Network
        y = net(x,xi,ai);
%         e = gsubtract(t,y);
        performance2(k,:) = perform(net,t,y); %%%%%%%%
        TT = cell2mat( t );
        YY = cell2mat( y );
        RMSE = sqrt(mean((YY - TT).^2));

        % View the Network
        % view(net)

        % Plots
        % Uncomment these lines to enable various plots.
        %figure, plotperform(tr)
        %figure, plottrainstate(tr)
        %figure, ploterrhist(e)
        %figure, pltregression(t,y)
        %figure, plotresponse(t,y)
        %figure, ploterrcorr(e)
        %figure, plotinerrcorr(x,e)

        % Closed Loop Network
        % Use this network to do multi-step prediction.
        % The function CLOSELOOP replaces the feedback input with a direct
        % connection from the outout layer.
%         netc = closeloop(net);
%         netc.name = [net.name ' - Closed Loop'];
%         % view(netc)
%         [xc,xic,aic,tc] = preparets(netc,{},{},T);
%         yc = netc(xc,xic,aic);
%         closedLoopPerformance = perform(net,tc,yc);  %%%%%%%%%%%%%%%%%%

        % Multi-step Prediction
        % Sometimes it is useful to simulate a network in open-loop form for as
        % long as there is known data T, and then switch to closed-loop to perform
        % multistep prediction. Here The open-loop network is simulated on the
        % known output series, then the network and its final delay states are
        % converted to closed-loop form to produce predictions for 5 more
        % timesteps.
        [x1,xio,aio,t] = preparets(net,{},{},T);
        [y1,xfo,afo] = net(x1,xio,aio);
        [netc,xic,aic] = closeloop(net,xfo,afo);
        [y2,xfc,afc] = netc(cell(0,Nmuberofsteps),xic,aic); %%%%%%%%%%%%%  (Nmuber of steps)
        NDVI(k,:) = cell2mat(y2);%%%%%%%%%%%%%%%%%%%%%%%%%%%
        
        % Further predictions can be made by continuing simulation starting with
        % the final input and layer delay states, xfc and afc.

        % Step-Ahead Prediction Network
        % For some applications it helps to get the prediction a timestep early.
        % The original network returns predicted y(t+1) at the same time it is
        % given y(t+1). For some applications such as decision making, it would
        % help to have predicted y(t+1) once y(t) is available, but before the
        % actual y(t+1) occurs. The network can be made to return its output a
        % timestep early by removing one delay so that its minimal tap delay is now
        % 0 instead of 1. The new network returns the same outputs as the original
        % network, but outputs are shifted left one timestep.
        %nets = removedelay(net);
       % nets.name = [net.name ' - Predict One Step Ahead'];
        % view(nets)
        %[xs,xis,ais,ts] = preparets(nets,{},{},T);
        %ys = nets(xs,xis,ais);
        % stepAheadPerformance = perform(nets,ts,ys)    %%%%%%%%%%%%%%%%%%
         
    end
    
    %store performance and NDVI values 
    temp0=['performance2'+ convertCharsToStrings(NameOfPointsTile3)]; 
    save(temp0,"performance2")   
    temp1=['NDVI'+convertCharsToStrings(NameOfPointsTile3)]; 
    save(temp1,"NDVI")   
    %% Make name of Variables in new matrix
    NumberofSteps=[1:20];
    for kk=1:20
        NameofstepsVariables(1,kk)="V" + (NumberofSteps(1,kk));
    end
    NewMatrix = cellstr(NameofstepsVariables);
    clear NameofstepsVariables
    clear NumberofSteps
    clear kk
%%  Add data of predicted variables (M steps) to the new matrix
    [m,n] = size(NDVI);
    for x=1:20
        for w=1:m
            w2=w+1;
            NewMatrix{w2,x}=NDVI(w,x);
        end
    end
    %% Add coordinate for new matrix of predicted values from original shp matrix
    NewMatrix{1,n+1}=('X'); %add X lable (field name)
    NewMatrix{1,n+2}=('Y');
    NewMatrix{1,n+3}=('MSE');
    A_cell2=A_cell';
    Coordinates=A_cell2(:,2:3);
     A = cell2mat(Coordinates);
    [m,n] = size(A);
    for N=1:m
        N2=N+1;
        NewMatrix{N2,21}=Coordinates{N,1};    
        NewMatrix{N2,22}=Coordinates{N,2};
        NewMatrix{N2,23}=performance2(N,1);
    end 
 
    %% store NDVI to xls file
    temp2=['NDVI'+convertCharsToStrings(NameOfPointsTile3)]; 
    xlswrite(temp2,NewMatrix);
    clear NewMatrix
    
    [m,n] = size(file);
    clc
    disp(b + " Out of " + n)
    steps_len=n;
    stepi=stepi+1;
    str2=sprintf('b=%d, k=%d.........%.2f%%',b,k,(stepi/steps_len)*100);
    disp(str2);
    toc
    time1(b) = toc
end
% plot(time1) 
% average_time = mean(time1)
% standard_deviation = std(time1)