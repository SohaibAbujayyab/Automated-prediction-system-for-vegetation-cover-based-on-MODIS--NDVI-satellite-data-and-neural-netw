%% make list of input tiles of shp files 
clear
clc
[file,path] = uigetfile('*.shp*','MultiSelect','on');
[m,n] = size(file);
%% 
stepi=0;
str1='';
for b=1:1     %for loop of each PointsTile file
    tic    
    NameOfPointsTile=file(1,b);
    NameOfPointsTile2 = char(NameOfPointsTile);
    NameOfPointsTile3 = NameOfPointsTile2(1:end-4);
    PathOfPointsTile = fullfile(path,NameOfPointsTile3);
    % disp(PathOfPointsTile)
    S = shaperead(PathOfPointsTile);   %read Shapefile (Shapefile must not have any other fields) 
    A_cell = struct2cell(S);
    YY2 = A_cell(5:end,:)';     %clean the data and take only numbers
    [m,n] = size(YY2);
    clear A_cell
    clear S
    
    for mm=1:m
        YY23=YY2(m,:);
        YY24 = cell2mat(YY23)';
        
        for i=1:n
            maxx=max(YY24);
            minn=min(YY24);

            NormalizedYY24(i,mm)=(YY24(i,1)-minn)/(maxx-minn);

        end
       
    end
        
    NormalizedYY24=NormalizedYY24';
        for x=1:300
        for w=1:m
             
            NormalizedYY25{w,x}=NormalizedYY24(w,x);
        end
        end

%     NormalizedYY25=num2cell(NormalizedYY24,1)';
 

   
    performance2=[];
    NDVI=[];
    for k=88:88     %for loop of each pixcel(Time-Series)
        T = NormalizedYY25(k,1:n);
        % Solve an Autoregression Time-Series Problem with a NAR Neural Network
        % Script generated by Neural Time Series app
        % Created 06-Jan-2019 03:09:06
        %
        % This script assumes this variable is defined:
        %
        %   T - feedback time series.
 
        % Choose a Training Function
        % For a list of all training functions type: help nntrain
        % 'trainlm' is usually fastest.
        % 'trainbr' takes longer but may be better for challenging problems.
        % 'trainscg' uses less memory. Suitable in low memory situations.
         trainFcn = 'trainlm';  % Levenberg-Marquardt backpropagation.
%        trainFcn = 'trainbr'; 
%        trainFcn = 'trainscg'; %
                     %   trainFcn = 'trainscg';

        % Create a Nonlinear Autoregressive Network
        feedbackDelays = 1:20;
        hiddenLayerSize = 73;
        net = narnet(feedbackDelays,hiddenLayerSize,'open',trainFcn);
        % Prepare the Data for Training and Simulation
        % The function PREPARETS prepares timeseries data for a particular network,
        % shifting time by the minimum amount to fill input states and layer
        % states. Using PREPARETS allows you to keep your original time series data
        % unchanged, while easily customizing it for networks with differing
        % numbers of delays, with open loop or closed loop feedback modes.
        [x,xi,ai,t] = preparets(net,{},{},T);
        % Setup Division of Data for Training, Validation, Testing
        net.divideParam.trainRatio = 70/100;
        net.divideParam.valRatio = 15/100;
        net.divideParam.testRatio = 15/100;

        % Train the Network
        [net,tr] = train(net,x,t,xi,ai);

        % Test the Network
        y = net(x,xi,ai);
        e = gsubtract(t,y);
        performance = perform(net,t,y) %%%%%%%%
        performance2(k,:)=performance;

        TT = cell2mat( t );
        YY = cell2mat( y );
        RMSE = sqrt(mean((YY - TT).^2))

        % View the Network
        % view(net)

        % Plots
        % Uncomment these lines to enable various plots.
        %figure, plotperform(tr)
        %figure, plottrainstate(tr)
        %figure, ploterrhist(e)
        %figure, pltregression(t,y)
        %figure, plotresponse(t,y)
        %figure, ploterrcorr(e)
        %figure, plotinerrcorr(x,e)

        % Closed Loop Network
        % Use this network to do multi-step prediction.
        % The function CLOSELOOP replaces the feedback input with a direct
        % connection from the outout layer.
        netc = closeloop(net);
        netc.name = [net.name ' - Closed Loop'];
        % view(netc)
        [xc,xic,aic,tc] = preparets(netc,{},{},T);
        yc = netc(xc,xic,aic);
        closedLoopPerformance = perform(net,tc,yc);  %%%%%%%%%%%%%%%%%%

        % Multi-step Prediction
        % Sometimes it is useful to simulate a network in open-loop form for as
        % long as there is known data T, and then switch to closed-loop to perform
        % multistep prediction. Here The open-loop network is simulated on the
        % known output series, then the network and its final delay states are
        % converted to closed-loop form to produce predictions for 5 more
        % timesteps.
        [x1,xio,aio,t] = preparets(net,{},{},T);
        [y1,xfo,afo] = net(x1,xio,aio);
        [netc,xic,aic] = closeloop(net,xfo,afo);
        [y2,xfc,afc] = netc(cell(0,20),xic,aic); %%%%%%%%%%%%%  (Nmuber of steps)

        NDVI(k,:) = cell2mat(y2);%%%%%%%%%%%%%%%%%%%%%%%%%%%
        

        % Further predictions can be made by continuing simulation starting with
        % the final input and layer delay states, xfc and afc.

        % Step-Ahead Prediction Network
        % For some applications it helps to get the prediction a timestep early.
        % The original network returns predicted y(t+1) at the same time it is
        % given y(t+1). For some applications such as decision making, it would
        % help to have predicted y(t+1) once y(t) is available, but before the
        % actual y(t+1) occurs. The network can be made to return its output a
        % timestep early by removing one delay so that its minimal tap delay is now
        % 0 instead of 1. The new network returns the same outputs as the original
        % network, but outputs are shifted left one timestep.
        %nets = removedelay(net);
       % nets.name = [net.name ' - Predict One Step Ahead'];
        % view(nets)
        %[xs,xis,ais,ts] = preparets(nets,{},{},T);
        %ys = nets(xs,xis,ais);
        % stepAheadPerformance = perform(nets,ts,ys)    %%%%%%%%%%%%%%%%%%
        %disp(k + " Out of " + m)
        
        %clear y1 y2 c ys ts x1 xc e tc  %T t
    end
    %clear y1 y2  y yc ys ts x1 xc c e tc   xs %T t
    
    %store performance and NDVI values 
    temp0=['performance2'+ convertCharsToStrings(NameOfPointsTile3)]; 
    save(temp0,"performance2")   
    temp1=['NDVI'+convertCharsToStrings(NameOfPointsTile3)]; 
    save(temp1,"NDVI")
    
    
    clear NormalizedYY24
    clear NormalizedYY25
    
    %% Make name of Variables in new matrix
    NumberofSteps=[1:20];
    for kk=1:20
        NameofstepsVariables(1,kk)="V" + (NumberofSteps(1,kk));
    end
    NewMatrix = cellstr(NameofstepsVariables);
    clear NameofstepsVariables
    clear NumberofSteps
    clear kk
%%  Add data of predicted variables (M steps) to the new matrix
    [m,n] = size(NDVI);
    
    for x=1:20
        for w=1:m
            w2=w+1;
            NewMatrix{w2,x}=NDVI(w,x);
        end
    end
%     clear x
%     clear w
%     clear w2
%     clear NDVI
    %% Add coordinate for new matrix of predicted values from original shp matrix
    NewMatrix{1,n+1}=('X'); %add X lable (field name)
    NewMatrix{1,n+2}=('Y');
    NewMatrix{1,n+3}=('MSE');
    Coordinates=YY2(:,2:3);
    A = cell2mat(Coordinates);
    [m,n] = size(A);
    for N=1:m
        N2=N+1;
        NewMatrix{N2,21}=Coordinates{N,1};    
        NewMatrix{N2,22}=Coordinates{N,2};
%         NewMatrix{N2,23}=performance2(N,3};
    end 
%     clear A Coordinates  N N2 %YY2
%     clear performance2


    %% store NDVI to xls file
    temp2=['NDVI'+convertCharsToStrings(NameOfPointsTile3)]; 
%     xlswrite(temp2,NewMatrix);
%     clear NewMatrix
    
    [m,n] = size(file);
    % clc
%     disp(b + " Out of " + n)
%     steps_len=n;
%     stepi=stepi+1;
%     str2=sprintf('b=%d, k=%d.........%.2f%%',b,k,(stepi/steps_len)*100);
%     disp(str2);
%     toc
%     time1(b) = toc
end
% plot(time1) 
% average_time = mean(time1)
% standard_deviation = std(time1)
